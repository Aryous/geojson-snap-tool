<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GISå›¾å±‚è¾¹ç¼˜æ•æ‰å·¥å…· â€“ ä¿®å¤ç‰ˆ v2</title>

    <!-- Leaflet æ ·å¼ -->
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
    />

    <!-- é¡µé¢æ ·å¼ï¼šä¸ä¹‹å‰ä¸€è‡´ï¼Œè¿™é‡Œåªä¿ç•™å…³é”®ä¿¡æ¯ -->
    <style>
        body {
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #fff;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #fff;
            padding: 20px 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2em;
            font-weight: 300;
        }
        .controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }
        .file-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            flex: 1;
            min-width: 200px;
        }
        .file-input-group label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }
        .file-input {
            padding: 8px 12px;
            border: 2px dashed #ced4da;
            border-radius: 8px;
            background: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-input:hover {
            border-color: #007bff;
            background: #f8f9ff;
        }
        .tolerance-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .tolerance-group label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }
        .tolerance-input {
            width: 100px;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 8px;
            font-size: 14px;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        .btn-primary {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: #fff;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 123, 255, 0.3);
        }
        .btn-secondary {
            background: #6c757d;
            color: #fff;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        .map-container {
            height: 600px;
            position: relative;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .status {
            padding: 15px 30px;
            background: #e9ecef;
            font-family: Consolas, monospace;
            font-size: 14px;
            color: #495057;
            max-height: 120px;
            overflow-y: auto;
        }
        .layer-info {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .layer-item {
            background: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .layer-item.layer2 {
            border-left-color: #dc3545;
        }
        .layer-item.layerFixed {
            border-left-color: #28a745;
        }
        .layer-item strong {
            display: block;
            margin-bottom: 5px;
        }
        .snap-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 1000;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ—ºï¸ GISå›¾å±‚è¾¹ç¼˜æ•æ‰å·¥å…· v2</h1>
            <p>æ•æ‰åä¼šç”Ÿæˆ<strong>ç»¿è‰²ä¿®å¤å±‚</strong>ï¼Œå¯å¯¼å‡ºä¸º GeoJSON</p>
        </div>

        <!-- æ§ä»¶ -->
        <div class="controls">
            <div class="control-group">
                <div class="file-input-group">
                    <label for="layer1">æºå›¾å±‚ (Layer 1)</label>
                    <input
                        type="file"
                        id="layer1"
                        class="file-input"
                        accept=".geojson,.json"
                    />
                </div>
                <div class="file-input-group">
                    <label for="layer2">ç›®æ ‡å›¾å±‚ (Layer 2)</label>
                    <input
                        type="file"
                        id="layer2"
                        class="file-input"
                        accept=".geojson,.json"
                    />
                </div>
                <div class="tolerance-group">
                    <label for="tolerance">æ•æ‰å®¹å·® (ç±³)</label>
                    <input
                        type="number"
                        id="tolerance"
                        class="tolerance-input"
                        value="50"
                        min="1"
                        max="10000"
                    />
                </div>
            </div>
            <div class="control-group">
                <button id="loadLayers" class="btn btn-primary">
                    ğŸ“ åŠ è½½å›¾å±‚
                </button>
                <button
                    id="snapLayers"
                    class="btn btn-primary"
                    disabled
                >
                    ğŸ”— æ‰§è¡Œæ•æ‰
                </button>
                <button
                    id="exportFixed"
                    class="btn btn-secondary"
                    disabled
                >
                    ğŸ’¾ å¯¼å‡ºä¿®å¤å±‚
                </button>
                <button id="clearAll" class="btn btn-secondary">
                    ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰
                </button>
            </div>
            <div class="layer-info" id="layerInfo"></div>
        </div>

        <!-- åœ°å›¾ -->
        <div class="map-container">
            <div id="map"></div>
            <div class="snap-indicator" id="snapIndicator">æ•æ‰ä¸­â€¦</div>
            <div class="legend">
                <div class="legend-item">
                    <div
                        class="legend-color"
                        style="background:#007bff"
                    ></div
                    ><span>æºå›¾å±‚</span>
                </div>
                <div class="legend-item">
                    <div
                        class="legend-color"
                        style="background:#dc3545"
                    ></div
                    ><span>ç›®æ ‡å›¾å±‚</span>
                </div>
                <div class="legend-item">
                    <div
                        class="legend-color"
                        style="background:#28a745"
                    ></div
                    ><span>ä¿®å¤å</span>
                </div>
            </div>
        </div>

        <div class="status" id="status">
            çŠ¶æ€: ç­‰å¾…åŠ è½½å›¾å±‚â€¦
        </div>
    </div>

    <!-- Leaflet -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <!-- Turf.jsï¼ˆç”¨äºè·ç¦»ä¸æœ€è¿‘ç‚¹è®¡ç®—ï¼‰ -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

    <script>
        class GISSnapTool {
            constructor() {
                this.map = null;

                this.layer1Data = null; // æº
                this.layer2Data = null; // ç›®æ ‡
                this.fixedLayerData = null; // ä¿®å¤å

                this.layer1Group = null;
                this.layer2Group = null;
                this.fixedGroup = null;

                this.snapIndicator =
                    document.getElementById("snapIndicator");

                this.init();
            }

            /* ===== åˆå§‹åŒ– ===== */
            init() {
                this.initMap();
                this.bindEvents();
                this.updateStatus("åˆå§‹åŒ–å®Œæˆ");
            }

            initMap() {
                this.map = L.map("map").setView([39.9, 116.4], 10);
                L.tileLayer(
                    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                    {
                        attribution: "Â© OSM",
                    }
                ).addTo(this.map);

                this.layer1Group = L.layerGroup().addTo(this.map);
                this.layer2Group = L.layerGroup().addTo(this.map);
                this.fixedGroup = L.layerGroup().addTo(this.map);
            }

            bindEvents() {
                document
                    .getElementById("loadLayers")
                    .addEventListener("click", () =>
                        this.loadLayers()
                    );
                document
                    .getElementById("snapLayers")
                    .addEventListener("click", () =>
                        this.performSnapping()
                    );
                document
                    .getElementById("exportFixed")
                    .addEventListener("click", () =>
                        this.exportFixed()
                    );
                document
                    .getElementById("clearAll")
                    .addEventListener("click", () =>
                        this.clearAll()
                    );

                ["layer1", "layer2"].forEach((id) =>
                    document
                        .getElementById(id)
                        .addEventListener("change", () =>
                            this.checkFilesSelected()
                        )
                );
            }

            /* ===== UI å·¥å…· ===== */
            updateStatus(msg) {
                const el = document.getElementById("status");
                el.textContent =
                    "[" +
                    new Date().toLocaleTimeString() +
                    "] " +
                    msg;
            }

            checkFilesSelected() {
                const l1 =
                    document.getElementById("layer1").files[0];
                const l2 =
                    document.getElementById("layer2").files[0];
                const btn = document.getElementById("loadLayers");
                btn.textContent =
                    l1 && l2 ? "ğŸ“ åŠ è½½å›¾å±‚ (å·²é€‰)" : "ğŸ“ åŠ è½½å›¾å±‚";
            }

            /* ===== è¯»å–æ–‡ä»¶ & è¿‡æ»¤ç©ºå‡ ä½• ===== */
            async readGeoJSON(file) {
                return new Promise((res, rej) => {
                    const r = new FileReader();
                    r.onload = () => {
                        try {
                            const d = JSON.parse(r.result);
                            res(this.filterEmpty(d));
                        } catch (e) {
                            rej(e);
                        }
                    };
                    r.onerror = () => rej(new Error("è¯»å–å¤±è´¥"));
                    r.readAsText(file);
                });
            }

            filterEmpty(d) {
                // åˆ é™¤ geometry = null æˆ–ç©ºåæ ‡çš„è¦ç´ 
                if (d.type === "FeatureCollection") {
                    d.features = d.features.filter(
                        (f) =>
                            f.geometry &&
                            f.geometry.coordinates &&
                            f.geometry.coordinates.length
                    );
                }
                return d;
            }

            /* ===== æ¸²æŸ“å›¾å±‚ ===== */
            displayLayer(data, group, color) {
                group.clearLayers();
                L.geoJSON(data, {
                    style: {
                        color,
                        weight: 3,
                        opacity: 0.8,
                        fillOpacity: 0.3,
                    },
                    pointToLayer: (f, ll) =>
                        L.circleMarker(ll, {
                            radius: 6,
                            color,
                            fillColor: color,
                            fillOpacity: 0.8,
                        }),
                }).addTo(group);
            }

            fitMap() {
                const layers = [];
                [this.layer1Group, this.layer2Group].forEach((g) =>
                    g.eachLayer((l) => {
                        if (l.getBounds) layers.push(l);
                    })
                );
                if (this.fixedGroup.getLayers().length) {
                    this.fixedGroup.eachLayer((l) =>
                        layers.push(l)
                    );
                }
                if (!layers.length) return;
                const bounds = L.featureGroup(layers).getBounds();
                if (bounds.isValid()) {
                    this.map.fitBounds(bounds, {
                        padding: [20, 20],
                    });
                }
            }

            layerStats(data) {
                return {
                    count:
                        data.type === "FeatureCollection"
                            ? data.features.length
                            : 1,
                    types: this.collectTypes(data).join(","),
                };
            }

            collectTypes(data) {
                const s = new Set();
                const add = (g) => {
                    if (g.type === "FeatureCollection") {
                        g.features.forEach(add);
                    } else s.add(g.geometry.type);
                };
                add(data);
                return [...s];
            }

            updateLayerInfo() {
                const info = document.getElementById("layerInfo");
                let html = "";

                if (this.layer1Data)
                    html += `<div class="layer-item"><strong>æºå›¾å±‚</strong><div>è¦ç´ : ${
                        this.layerStats(this.layer1Data).count
                    }</div><div>ç±»å‹: ${
                        this.layerStats(this.layer1Data).types
                    }</div></div>`;

                if (this.layer2Data)
                    html += `<div class="layer-item layer2"><strong>ç›®æ ‡å›¾å±‚</strong><div>è¦ç´ : ${
                        this.layerStats(this.layer2Data).count
                    }</div><div>ç±»å‹: ${
                        this.layerStats(this.layer2Data).types
                    }</div></div>`;

                if (this.fixedLayerData)
                    html += `<div class="layer-item layerFixed"><strong>ä¿®å¤å</strong><div>è¦ç´ : ${
                        this.layerStats(this.fixedLayerData).count
                    }</div><div>ç±»å‹: ${
                        this.layerStats(this.fixedLayerData).types
                    }</div></div>`;

                info.innerHTML = html;
            }

            /* ===== åŠ è½½ä¸¤ä¸ªå›¾å±‚ ===== */
            async loadLayers() {
                const f1 =
                    document.getElementById("layer1").files[0];
                const f2 =
                    document.getElementById("layer2").files[0];
                if (!f1 || !f2) {
                    this.updateStatus("è¯·é€‰æ‹©ä¸¤ä¸ª GeoJSON æ–‡ä»¶");
                    return;
                }

                try {
                    this.updateStatus("æ­£åœ¨åŠ è½½å›¾å±‚â€¦");
                    this.clearAll(false); // ä¸æ¸…ç©ºæ–‡ä»¶é€‰æ‹©

                    [
                        this.layer1Data,
                        this.layer2Data,
                    ] = await Promise.all([
                        this.readGeoJSON(f1),
                        this.readGeoJSON(f2),
                    ]);

                    this.displayLayer(
                        this.layer1Data,
                        this.layer1Group,
                        "#007bff"
                    );
                    this.displayLayer(
                        this.layer2Data,
                        this.layer2Group,
                        "#dc3545"
                    );

                    this.fitMap();
                    this.updateLayerInfo();

                    document.getElementById(
                        "snapLayers"
                    ).disabled = false;
                    this.updateStatus("å›¾å±‚åŠ è½½å®Œæˆ");
                } catch (e) {
                    console.error(e);
                    this.updateStatus("åŠ è½½å¤±è´¥: " + e.message);
                }
            }

            /* ===== æ•æ‰æ ¸å¿ƒ ===== */

            /* â€”â€” é€’å½’éå†åæ ‡æ•°ç»„ï¼Œcallback è¿”å›æ–°åæ ‡æˆ–åŸåæ ‡ â€”â€” */
            traverseCoords(coords, cb) {
                if (
                    typeof coords[0] === "number" &&
                    typeof coords[1] === "number"
                ) {
                    return cb(coords);
                }
                return coords.map((c) => this.traverseCoords(c, cb));
            }

            /* â€”â€” ä» layer2Data ä¸­æ”¶é›†æ‰€æœ‰ç›®æ ‡ç‚¹åæ ‡ â€”â€” */
            collectTargetCoords() {
                const targets = [];

                const collect = (g) => {
                    if (g.type === "FeatureCollection") {
                        g.features.forEach(collect);
                    } else if (g.geometry) {
                        this.traverseCoords(
                            g.geometry.coordinates,
                            (pt) => targets.push(pt)
                        );
                    }
                };
                collect(this.layer2Data);
                return targets;
            }

            performSnapping() {
                const tolMeters = parseFloat(
                    document.getElementById("tolerance").value
                );

                if (!tolMeters || tolMeters <= 0) {
                    this.updateStatus("è¯·è¾“å…¥æœ‰æ•ˆå®¹å·®ï¼ˆç±³ï¼‰");
                    return;
                }
                if (!this.layer1Data || !this.layer2Data) {
                    this.updateStatus("è¯·å…ˆåŠ è½½ä¸¤ä¸ªå›¾å±‚");
                    return;
                }

                // UI
                this.snapIndicator.style.display = "block";
                this.updateStatus(
                    `å¼€å§‹æ•æ‰ï¼Œå®¹å·®: ${tolMeters} m`
                );

                /* â€”â€” æ”¶é›†ç›®æ ‡å›¾å±‚æ‰€æœ‰é¡¶ç‚¹ï¼ˆç»çº¬åº¦ï¼‰ â€”â€” */
                const targetCoords = this.collectTargetCoords();

                /* è½¬æˆ Turf Point ï¼Œä¾¿äºè·ç¦»è®¡ç®— */
                const targetPoints = targetCoords.map((c) =>
                    turf.point(c)
                );

                /* â€”â€” å¯¹æºå›¾å±‚è¿›è¡Œæ·±æ‹·è´å¹¶ä¿®æ”¹ â€”â€” */
                const fixed = JSON.parse(
                    JSON.stringify(this.layer1Data)
                );

                let moveCount = 0;

                /* â€”â€” éå†æºå›¾å±‚é¡¶ç‚¹ï¼Œè‹¥åœ¨å®¹å·®å†…åˆ™æ›¿æ¢ â€”â€” */
                const processFeature = (f) => {
                    f.geometry.coordinates = this.traverseCoords(
                        f.geometry.coordinates,
                        (coord) => {
                            const p = turf.point(coord);

                            // å…ˆåšä¸€ä¸ªéå¸¸ç²—çš„å®¹å·®ç­›é€‰ï¼Œæé«˜æ•ˆç‡
                            let nearest = null;
                            let nearestDist = Infinity;

                            // çº¿æ€§æ‰«æï¼›å¯æ ¹æ®éœ€æ±‚æ¢ KD-Tree
                            for (let tp of targetPoints) {
                                const d = turf.distance(
                                    p,
                                    tp,
                                    { units: "meters" }
                                );
                                if (d < nearestDist) {
                                    nearestDist = d;
                                    nearest = tp;
                                }
                            }

                            if (nearest && nearestDist <= tolMeters) {
                                moveCount++;
                                return nearest.geometry.coordinates;
                            }
                            return coord; // ä¸å˜
                        }
                    );
                };

                if (fixed.type === "FeatureCollection") {
                    fixed.features.forEach(processFeature);
                } else {
                    processFeature(fixed);
                }

                /* â€”â€” ä¿å­˜ & æ¸²æŸ“ â€”â€” */
                this.fixedLayerData = fixed;
                this.fixedGroup.clearLayers();
                this.displayLayer(
                    this.fixedLayerData,
                    this.fixedGroup,
                    "#28a745"
                );

                // æ›´æ–°æŒ‰é’® & è§†å›¾
                document.getElementById(
                    "exportFixed"
                ).disabled = false;
                this.fitMap();
                this.updateLayerInfo();

                // UI ç»“æŸ
                this.snapIndicator.style.display = "none";
                this.updateStatus(
                    `æ•æ‰å®Œæˆï¼Œç§»åŠ¨é¡¶ç‚¹ ${moveCount} ä¸ª`
                );
            }

            /* ===== å¯¼å‡ºä¿®å¤åå›¾å±‚ ===== */
            exportFixed() {
                if (!this.fixedLayerData) return;
                const blob = new Blob(
                    [JSON.stringify(this.fixedLayerData)],
                    { type: "application/json" }
                );
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "fixed_layer.geojson";
                a.click();
                URL.revokeObjectURL(url);

                this.updateStatus("å·²å¯¼å‡º fixed_layer.geojson");
            }

            /* ===== æ¸…é™¤ ===== */
            clearAll(resetFiles = true) {
                this.layer1Group.clearLayers();
                this.layer2Group.clearLayers();
                this.fixedGroup.clearLayers();

                this.layer1Data = null;
                this.layer2Data = null;
                this.fixedLayerData = null;

                document.getElementById(
                    "snapLayers"
                ).disabled = true;
                document.getElementById(
                    "exportFixed"
                ).disabled = true;

                if (resetFiles) {
                    document.getElementById("layer1").value = "";
                    document.getElementById("layer2").value = "";
                    this.checkFilesSelected();
                }

                this.updateLayerInfo();
                this.updateStatus("å·²æ¸…ç©ºæ‰€æœ‰å›¾å±‚");
            }
        }

        /* ===== å¯åŠ¨ ===== */
        window.addEventListener("load", () => new GISSnapTool());
    </script>
</body>
</html>
